# Установка командной строки для пользователей Windows

1. Скачайте одну из версий из категории *Standalone Installer* на сайте: https://git-scm.com/download/win

2. Запустите программу установки. Обратите внимание, куда будет установлен Git. Обычно это директория C:\Program Files\Git

3. Проверьте, что в списке устанавливаемых программ стоит галочка напротив пункта *Git Bash Here* - это позволит открывать консоль с Git в любой папке.

4. После окончания установки нажмите *Finish*


# Первый запуск Git Bash

1. Запустите программу Git Bash. Сделать это можно двумя способами. Можно ввести название программы в окно поиска на панели задач. А можно открыть директорию, в которой был установлен Git. Перейдите в bin и запустите файл bash exe.

2. Откроется консоль, в которой будет написано что-то похожее *USER_NAME@HOST_NAME MINGW64 ~*

3. Символ *$* означает, что программа ждёт ваших команд


# Команды чтобы не запутаться

- pwd - поможет узнать где вы сейчас находитесь
- cd - для перехода в другие папки (пример: cd /projects/github), (cd ~ переход сразу в домашнюю директорию), если в названии папки пробелы используйте "", (cd . чтобы обратиться к текущей директории)
- ls - вывести содержимое директории (ls -a вывести скрытые файлы), (ls ~ выведет содержимое домашней директории), (ls .. покажет содержимое родительской директории)


# Создание файлов и директорий

- touch my_new_file.txt - _создание_ _файла_ (хорошей практикой при создании считается указывать его расширение)
- mkdir new_dir - создание директории под названием new_dir, (mkdir -p dir1/dir_inside/dir_deeper создание папки dir_deeper в папке dir_inside, которая в папке dir1)


# Копирование файлов 

- cp что_копируем куда_копируем (cp index.html src/ скопировали index.html в папку src), (можно указать сразу несколько файлов)


# Перемещение файлов и папок

- mv table.csv ./ very_important_files (указываем имя файла, который хотим переместить, потом путь - куда перемещаем)


# Операции с папками и файлами: чтение и удаление

- cat myfile.txt - распечатали содержимое файла myfile.txt
- rm example.txt - удалили файл example.txt из текущей папки
- rmdir images - команда удалит папку images из текущей директории, если папка images пуста
- rm -r images - удалит папку images со всем её содержимым из текущей директории

* Удаление объектов командами rm и rmdir необратимо -  в этом случае файлы и папки не попадают в корзину и исчезают навсегда.

* Команды в терминале можно указывать не по одной, а срзу списком, для этого их нужно разделить двумя амперсандами &&.

* С помощью стрелок вверх и вниз можно перемещаться между командами введёнными в терминал ранее.


# Настройка Git

Сейчас вы работает в одиночку, но в дальнейшем вам может понадобиться использовать Git в команде. Чтобы участникам 
проекта было понятно, кто и какие изменения вносил, нужно представиться и указать имя пользователя и адрес электронной почты.

Вы можете указать любую электронную почту и любое имя. Сделать этом можно с помощью команды git config с ключом --global
При этом не имеет значения, в какой директории вы находитесь прямо сейчас: *git config --global* сработает везде.

В качестве значения user.name нужно указать своё имя или никнейм. Для настройки параметра user.email указывают электронную почту.

- git config --global user.name "User Ivan"
- git cinfig --global user.email username@yabdex.ru

Все глобальные настройки Git хранит в файле *.gitconfig* в домашней директории. Команда запишет в этот файл указанные имя и почту.
Чтобы убедиться в этом, можно вызвать команду для чтения файлов.

- git ~/.gitconfig

Другой способ проверки - вывести содержимое файла конфигурации Git той же командой git config с фдагом --list.

- git config --list

В ответ командная строка покажет текущие значения настроек.

user.name=Username
user.email=username@yandex.ru 


# Инициализируем репозиторий

## Сделать папку репозиторием

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием.
Для этого следует переместиться в неё и ввести команду git init.

Например, создайте папку first_project и сделайте её Git-репозиторием:
перейдите в ней с помощью команды cd и выполните git init.

- cd ~/dev/first_project (перешли в нужную папку)
- git init (создали репозиторий)

## Разгитить папку, если что-то пошло не так

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить».
Для этого нужно удалить скрытую подпапку .git.

- cd <папка с репозиторием>
- rm -rf .git (удалили подпапку .git)

Разберём подробнее, что такое -rf:

* ключ -r позволяет удалять папки вместе с их содержимым
* ключ -f избавит вас от вопросов вроде "Вы точно хотите удалить файл?"

Будьте осторожны: в подпапке .git хранится история изменений. 
Если удалить .git, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

## Проверить состояние репозитория

- git status (показывает текущее состояние репозитория)

Команда git status выведет:
* название текущей ветки: On branch master или On branch main;
* сообщение о том, что в репозитории ещё нет коммитов: No commits yet;
* сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — nothing to commit (create/copy files and use "git add" to track).


# Добавляем файлы в репозиторий

## Подготовить файлы к сохранению

- git add --all (подготовили к сохранению все файлы в репозитории), (можно без -all просто название файла)
- git status (проверили статус)

* Файлы отмеченные зелённым, теперь отслеживаются и готовы к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.


# Делаем первый коммит

## Выполнить коммит

- git commit -m "Комментарий к комиту"

После нажатия Enter текущая версия файлов будет сохранена в репозитории с сообщением Комментарий к комиту. Коммит (по названию команды git commit) — это по сути список файлов с их контентом.

Команда git commit выведет информацию о коммите.
* [master (root-commit) baa3b6e] значит:
* коммит был в ветке master;
* root-commit — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
* baa3b6e — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
* 2 files changed, 1 insertion(+) значит:
* изменились два файла (readme.txt и todo.txt);
* одна строка была добавлена (1. Пройти пару уроков по Git.).
* Строки вида create mode 100644 readme.txt — это более подробная информация о новых (добавленных в Git) файлах.
* create (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово delete (англ. «удалить»).
* mode 100644 сообщает, что это обычный файл. Также возможны варианты 100755 для исполняемых файлов (например, что-нибудь.exe) и 120000 для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение. 

## Посмотреть историю коммитов

- git log (выведет комментарий и основную информацию о коммитах)


# Связываем локальный и удалённый репозитории

## Привязать удалённый репозиторий к локальному 

- git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git
- git remote -v (убедиться, что репозитории связаны), (-v короткая форма флага --verbose "подробный")

# Синхронизируем локальный и удалённый репозитории

## Основная ветка

Мы упоминали, что каждый коммит сохраняет актуальное состояние файлов. Сами же коммиты хранятся в ветках (англ. branch).
Если коммит — это снимок состояния файлов, то ветка — временна́я шкала, на которой расположены эти снимки. Ветка всегда начинается от одного из коммитов.
В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом.
Самая первая ветка в репозитории появляется автоматически и называется main (англ. «основная») или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.

## Отправить изменения на удалённый репозиторий

- git push -u origin main (если команда приведёт к ошибке, попробуйте заменить main на master)

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). 
Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.

Зайдите в репозиторий first-project на GitHub. Вы увидите, что в репозитории появились файлы с изменениями.


## Файл README.md

Чтобы другие пользователи, а также потенциальные клиенты или работодатели могли понять, что представляет собой проект, его нужно описать. 
Такое описание принято указывать в файле README.md (от англ. read — «прочитай» и me — «меня»).

Подробнее о том, зачем нужен README.md:

1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
3. Документация проекта — подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если они есть.

Пример файла README.md - [Пример](https://github.com/git/git/blob/master/README.md "Пример файла README.md")

README.md — текстовый файл, который можно создать командой touch, а затем редактировать так же, как и любой другой текстовый документ. Например, в блокноте.

Преимущество README.md в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. 
Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. Маркда́ун — это специальный язык разметки. 
Он позволяет красиво отформатировать текстовый документ.

Основные инструменты и как ими пользоваться: [здесь](https://www.markdownguide.org/cheat-sheet/ "Шпаргалка по markdown!") и [здесь](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c "Гайд по использованию").

# Хеш - идентификатор коммита

В процессе работы с Git вам будет часто встречаться понятие «хеш коммита».
Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду git log и выводили историю коммитов.

## Что такое хеш. Хеширование коммитов.

Хеширование (от англ. hash, "рубить", "крошить", "мешанина") - это способ преобразовать набор данных и получить их "отпечаток".

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв А - F (неважно, заглавных или строчных).
Она обладает следующими важными свойствами:

* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 на этом [сайте](https://emn178.github.io/online-tools/sha1.html) — попробуйте ввести в поле input (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле output (англ. «вывод»).

## Хеш - основной идентификатор коммита

Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.

# Исследуем лог

После вызова git log появляется список коммитов.

Разберём элементы, из которых состоит описание:
* строка из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
* в конце находится сообщение коммита.

## Получить сокращенный лог

- git log --oneline (получить сокращённый лог, флаг --oneline значит "одной строкой")

В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. 
Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

* Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской раскладке клавиатуры.

# HEAD - всему голова

При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов.

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.

- cd .git/
- ls
- cat HEAD (в файле будет такая ссылка: ref: refs/heads/master)

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки).
Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита.
Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.



# Статусы файлов в Git

До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог git add, а можно было просто сделать коммит (svn commit). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.
Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории.
Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

Статусы:

* *untracked* (англ. «неотслеживаемый») Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
* *staged* (англ. «подготовленный») После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
* *tracked* (англ. «отслеживаемый») Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* *modified* (англ. «изменённый») Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

- Staging area, index и cache Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached. Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.
- Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.

Типичный жизненный цикл файла в Git.

```mermaid
graph LR;
  untracked -- "git add" --> staged;
  staged -- "Изменения" --> modified;
  staged   -- "git commit"     --> tracked/comitted;
  modified -- "git add" --> staged;
  tracked/comitted -- "Изменения" --> modified;

```

1. Файл только что создали. Git про него ещё ничего не знает. Состояние: *untracked*.
2. Файл добавили в staging area с помощью *git add*. Состояние: *staged* (+ *tracked*).
    * Возможно, изменили файл ещё раз. Состояния: *staged*, *modified* (+ *tracked*).
    * Обратите внимание: *staged* и *modified* у одного файла, но у разных его версий.
    * Ещё раз выполнили *git add*. Состояние: *staged* (+ *tracked*).
3. Сделали коммит с помощью *git commit*. Состояние: *tracked*.
4. Изменили файл. Состояние: *modified* (+ *tracked*).
5. Снова добавили в *staging area* с помощью *git add*. Состояния: *staged* (+ *tracked*).
6. Сделали коммит. Состояния: *tracked*.


 